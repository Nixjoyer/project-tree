from pathlib import Path
from typing import Optional, Set


HEADER = "# Project Structure\n\n_Generated by projtree_\n\n"
CODE_BLOCK_OPEN = "```\n"
CODE_BLOCK_CLOSE = "```\n"


def generate_markdown_tree(
    root_path: Path,
    ignore: Optional[Set[str]] = None,
) -> str:
    """
    Generate a deterministic Markdown representation of a directory tree.

    :param root_path: Root directory to scan
    :param ignore: Set of directory or file names to omit
    :return: Markdown string
    """
    ignore = ignore or set()

    lines: list[str] = []
    lines.append(".")

    def should_ignore(path: Path) -> bool:
        return path.name in ignore

    def sorted_children(path: Path) -> list[Path]:
        children = [p for p in path.iterdir() if not should_ignore(p)]
        dirs = sorted(
            (p for p in children if p.is_dir()),
            key=lambda p: p.name.casefold(),
        )
        files = sorted(
            (p for p in children if p.is_file()),
            key=lambda p: p.name.casefold(),
        )
        return dirs + files

    def walk(current_path: Path, prefix: str) -> None:
        children = sorted_children(current_path)
        count = len(children)

        for index, child in enumerate(children):
            is_last = index == count - 1
            branch = "└── " if is_last else "├── "
            lines.append(f"{prefix}{branch}{child.name}")

            if child.is_dir():
                extension = "    " if is_last else "│   "
                walk(child, prefix + extension)

    walk(root_path, "")

    body = "\n".join(lines) + "\n"

    return (
        HEADER
        + CODE_BLOCK_OPEN
        + body
        + CODE_BLOCK_CLOSE
    )
